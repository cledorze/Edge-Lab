apiVersion: v1
kind: ConfigMap
metadata:
  name: update-ingress-scripts
  namespace: demo-workload-site-b
data:
  update-ingress-hostname.sh: |
    #!/bin/bash
    # Optimized script to update Ingress hostname with Ingress Controller IP
    # Automatically detects Traefik LoadBalancer, nginx LoadBalancer, or falls back to node IP
    # Uses sslip.io for dynamic DNS resolution
    
    set -o errexit
    set -o nounset
    set -o pipefail
    
    # Configuration from environment variables
    INGRESS_NAME="${INGRESS_NAME:-demo-workload-site-b}"
    NAMESPACE="${NAMESPACE:-demo-workload-site-b}"
    HOSTNAME_PREFIX="${HOSTNAME_PREFIX:-demo-workload-site-b}"
    MAX_WAIT="${MAX_WAIT:-60}"  # Reduced from 120s - faster failure for non-LoadBalancer cases
    
    # Colors for output (optional, but helpful)
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    NC='\033[0m' # No Color
    
    log_info() { echo -e "${GREEN}[INFO]${NC} $*" >&2; }
    log_warn() { echo -e "${YELLOW}[WARN]${NC} $*" >&2; }
    log_error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }
    
    # Function to validate IP address format
    is_valid_ip() {
      local ip="$1"
      [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]] || return 1
      # Check each octet is 0-255
      IFS='.' read -ra ADDR <<< "$ip"
      for i in "${ADDR[@]}"; do
        [[ $i -ge 0 && $i -le 255 ]] || return 1
      done
      return 0
    }
    
    # Function to get LoadBalancer IP from a service
    get_loadbalancer_ip() {
      local svc_name="$1"
      local namespace="${2:-kube-system}"
      local ip
      
      ip=$(kubectl get svc "$svc_name" -n "$namespace" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
      
      # Also check for hostname (some LoadBalancers use hostname instead of IP)
      if [[ -z "$ip" ]] || [[ "$ip" == "null" ]]; then
        local hostname
        hostname=$(kubectl get svc "$svc_name" -n "$namespace" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
        if [[ -n "$hostname" ]] && [[ "$hostname" != "null" ]]; then
          # Try to resolve hostname to IP
          ip=$(getent hosts "$hostname" 2>/dev/null | awk '{print $1}' | head -1 || echo "")
        fi
      fi
      
      if [[ -n "$ip" ]] && [[ "$ip" != "null" ]] && is_valid_ip "$ip"; then
        echo "$ip"
        return 0
      fi
      return 1
    }
    
    # Function to wait for LoadBalancer IP with timeout
    wait_for_loadbalancer_ip() {
      local svc_name="$1"
      local namespace="${2:-kube-system}"
      local max_wait="${3:-$MAX_WAIT}"
      local waited=0
      local ip=""
      
      log_info "Waiting for $svc_name LoadBalancer IP (max ${max_wait}s)..."
      
      while [[ $waited -lt $max_wait ]]; do
        if ip=$(get_loadbalancer_ip "$svc_name" "$namespace"); then
          log_info "$svc_name LoadBalancer IP found: $ip"
          echo "$ip"
          return 0
        fi
        
        sleep 2
        waited=$((waited + 2))
        if [[ $((waited % 10)) -eq 0 ]]; then
          log_info "Still waiting... (${waited}s/${max_wait}s)"
        fi
      done
      
      log_warn "$svc_name LoadBalancer IP not available after ${max_wait}s"
      return 1
    }
    
    # Function to get node IP (InternalIP)
    get_node_ip() {
      local node_name="${1:-}"
      
      if [[ -z "$node_name" ]]; then
        # Get first node name
        node_name=$(kubectl get nodes -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
      fi
      
      if [[ -z "$node_name" ]]; then
        return 1
      fi
      
      local ip
      ip=$(kubectl get node "$node_name" -o jsonpath='{.status.addresses[?(@.type=="InternalIP")].address}' 2>/dev/null || echo "")
      
      if [[ -n "$ip" ]] && is_valid_ip "$ip"; then
        echo "$ip"
        return 0
      fi
      
      return 1
    }
    
    # Main function to detect Ingress Controller IP
    detect_ingress_ip() {
      local ip=""
      
      log_info "Detecting Ingress Controller IP..."
      
      # Strategy 1: Try Traefik LoadBalancer (with MetalLB)
      if kubectl get svc traefik -n kube-system &>/dev/null; then
        if ip=$(wait_for_loadbalancer_ip "traefik" "kube-system" "$MAX_WAIT"); then
          echo "$ip"
          return 0
        fi
      fi
      
      # Strategy 2: Try nginx ingress controller LoadBalancer
      local nginx_services=("rke2-ingress-nginx-controller" "ingress-nginx-controller" "nginx-ingress-controller")
      for svc_name in "${nginx_services[@]}"; do
        if kubectl get svc "$svc_name" -n kube-system &>/dev/null 2>&1; then
          log_info "Found $svc_name service, checking for LoadBalancer IP..."
          if ip=$(get_loadbalancer_ip "$svc_name" "kube-system"); then
            log_info "$svc_name LoadBalancer IP found: $ip"
            echo "$ip"
            return 0
          fi
          # Quick check only, don't wait for nginx (usually NodePort in RKE2)
          log_info "$svc_name exists but no LoadBalancer IP (likely NodePort)"
        fi
      done
      
      # Strategy 3: Fallback to node IP (for single-node clusters or NodePort)
      log_info "No LoadBalancer found, using node IP (single-node/NodePort mode)..."
      if ip=$(get_node_ip); then
        log_info "Using node IP: $ip"
        echo "$ip"
        return 0
      fi
      
      log_error "Could not determine Ingress Controller IP"
      return 1
    }
    
    # Function to update Ingress hostname
    update_ingress_hostname() {
      local ingress_name="$1"
      local namespace="$2"
      local new_host="$3"
      
      # Check if Ingress exists
      if ! kubectl get ingress "$ingress_name" -n "$namespace" &>/dev/null; then
        log_error "Ingress $ingress_name not found in namespace $namespace"
        return 1
      fi
      
      # Get current hostname
      local current_host
      current_host=$(kubectl get ingress "$ingress_name" -n "$namespace" -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "")
      
      # Check if update is needed
      if [[ "$current_host" == "$new_host" ]]; then
        log_info "Ingress hostname already correct: $new_host"
        return 0
      fi
      
      # Check if Ingress has rules
      local has_rules
      has_rules=$(kubectl get ingress "$ingress_name" -n "$namespace" -o jsonpath='{.spec.rules}' 2>/dev/null || echo "[]")
      
      if [[ "$has_rules" == "[]" ]] || [[ -z "$current_host" ]]; then
        # No rules or empty hostname - add new rule
        log_info "Adding Ingress rule with hostname: $new_host"
        kubectl patch ingress "$ingress_name" -n "$namespace" --type='json' -p="[
          {\"op\": \"add\", \"path\": \"/spec/rules\", \"value\": [
            {
              \"host\": \"$new_host\",
              \"http\": {
                \"paths\": [
                  {
                    \"path\": \"/\",
                    \"pathType\": \"Prefix\",
                    \"backend\": {
                      \"service\": {
                        \"name\": \"$ingress_name\",
                        \"port\": {\"number\": 80}
                      }
                    }
                  }
                ]
              }
            }
          ]}
        ]" || {
          log_error "Failed to add Ingress rule"
          return 1
        }
      else
        # Update existing rule hostname
        log_info "Updating Ingress hostname from '$current_host' to '$new_host'"
        kubectl patch ingress "$ingress_name" -n "$namespace" --type='json' -p="[
          {\"op\": \"replace\", \"path\": \"/spec/rules/0/host\", \"value\": \"$new_host\"}
        ]" || {
          log_error "Failed to update Ingress hostname"
          return 1
        }
      fi
      
      # Verify update
      local verified_host
      verified_host=$(kubectl get ingress "$ingress_name" -n "$namespace" -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "")
      
      if [[ "$verified_host" == "$new_host" ]]; then
        log_info "✓ Verification successful: Ingress hostname is $verified_host"
        log_info "✓ Access URL: http://$new_host"
        return 0
      else
        log_warn "Verification failed. Expected '$new_host', got '$verified_host'"
        return 1
      fi
    }
    
    # Main execution
    main() {
      log_info "=== Updating Ingress hostname with Ingress Controller IP ==="
      log_info "Ingress: $INGRESS_NAME"
      log_info "Namespace: $NAMESPACE"
      log_info "Hostname prefix: $HOSTNAME_PREFIX"
      echo ""
      
      # Detect Ingress Controller IP
      local ingress_ip
      if ! ingress_ip=$(detect_ingress_ip); then
        log_error "Failed to detect Ingress Controller IP"
        log_error "The Ingress will need to be updated manually"
        exit 1
      fi
      
      # Build new hostname with sslip.io
      local new_host="${HOSTNAME_PREFIX}.${ingress_ip}.sslip.io"
      log_info "Target hostname: $new_host"
      echo ""
      
      # Update Ingress
      if update_ingress_hostname "$INGRESS_NAME" "$NAMESPACE" "$new_host"; then
        log_info "✓ Ingress hostname update completed successfully"
        exit 0
      else
        log_error "Failed to update Ingress hostname"
        exit 1
      fi
    }
    
    # Run main function
    main "$@"
